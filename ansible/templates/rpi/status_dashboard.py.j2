#!/usr/bin/env python3
"""
Raspberry Pi Homelab Dashboard
Displays system status on 480x320 framebuffer display
"""

import os
import time
import subprocess
import struct
import socket
import re
import requests
import json
import shutil
import threading
from datetime import timedelta, datetime, timezone
from PIL import Image, ImageDraw, ImageFont
import urllib3
try:
    import evdev
    from select import select
    HAS_EVDEV = True
except ImportError:
    HAS_EVDEV = False

# Disable SSL warnings for self-signed certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- CONFIGURATION ---
FB_DEVICE = "/dev/fb1"
SCREEN_WIDTH = 480
SCREEN_HEIGHT = 320

# OPNsense API Configuration
OPNSENSE_IP = "{{ vault_gateway_ip }}"
OPNSENSE_API_KEY = "{{ vault_opnsense_api_key }}"
OPNSENSE_API_SECRET = "{{ vault_opnsense_api_secret }}"
WAN_INTERFACE = "pppoe2"

# Weather Configuration (Brussels)
LATITUDE = "50.8503"
LONGITUDE = "4.3517"

# Colors
COLOR_BG = (0, 0, 0)
COLOR_TEXT = (255, 255, 255)
COLOR_ACCENT = (0, 200, 255)  # Cyan
COLOR_OK = (0, 255, 0)
COLOR_WARN = (255, 165, 0)
COLOR_ERR = (255, 0, 0)
COLOR_DIM = (100, 100, 100)
COLOR_CARD_BG = (10, 10, 10)
COLOR_BORDER = (40, 40, 40)

# Backup status file
BACKUP_JSON_PATH = "/mnt/appdata/rclone/backup_status.json"

# Services to monitor
# (Name, IP, Port/None for ping)
SERVICES = [
    ("Router", "{{ vault_gateway_ip }}", None),
    ("Proxmox", "{{ vault_pve_ip }}", None),
    ("AdGuard", "127.0.0.1", 53),
    ("HomeAsst", "127.0.0.1", 8123),
    ("Homepage", "127.0.0.1", 8082),
]

# Global variables
current_page = 0
TOTAL_PAGES = 3
last_wan_stats = None
last_wan_time = None
screen_on = False
cached_weather = None
last_weather_time = 0

# --- SYSTEM STATS HELPERS ---

def get_disk_usage(path):
    """Get disk usage for a path"""
    try:
        total, used, free = shutil.disk_usage(path)
        percent = (used / total) * 100
        return percent, total, used, free
    except:
        return 0, 0, 0, 0

def get_uptime():
    """Get system uptime in human readable format"""
    try:
        with open('/proc/uptime', 'r') as f:
            uptime_seconds = float(f.readline().split()[0])
        td = timedelta(seconds=uptime_seconds)
        days = td.days
        hours = td.seconds // 3600
        minutes = (td.seconds // 60) % 60
        
        if days > 0:
            return f"{days}d {hours}h {minutes}m"
        return f"{hours}h {minutes}m"
    except:
        return "Unknown"

def get_temp():
    """Get Raspberry Pi temperature"""
    try:
        with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
            temp = int(f.read().strip()) / 1000.0
        return temp
    except:
        return 0.0

def get_internet_latency():
    """Ping Cloudflare DNS to check internet latency"""
    try:
        cmd = ['ping', '-c', '1', '-W', '1', '1.1.1.1']
        output = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
        match = re.search(r'time=([\d.]+)', output)
        if match:
            return float(match.group(1))
        return None
    except:
        return None

# --- WEATHER ---

def get_weather():
    """Get current weather from Open-Meteo"""
    global cached_weather, last_weather_time
    
    # Update every 15 minutes
    if time.time() - last_weather_time < 900 and cached_weather:
        return cached_weather
        
    try:
        url = f"https://api.open-meteo.com/v1/forecast?latitude={LATITUDE}&longitude={LONGITUDE}&current_weather=true"
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            cached_weather = response.json().get('current_weather')
            last_weather_time = time.time()
            return cached_weather
    except:
        pass
    return cached_weather

def get_weather_desc(code):
    """Map WMO weather code to text"""
    # Simplified WMO codes
    if code == 0: return "Clear Sky"
    if code in [1, 2, 3]: return "Partly Cloudy"
    if code in [45, 48]: return "Foggy"
    if code in [51, 53, 55]: return "Drizzle"
    if code in [61, 63, 65]: return "Rain"
    if code in [71, 73, 75]: return "Snow"
    if code in [95, 96, 99]: return "Thunderstorm"
    return "Unknown"

# --- BACKUP STATUS ---
def get_time_ago(date_str):
    """Calcule le temps √©coul√© depuis une date ISO en UTC"""
    if not date_str or date_str == "N/A":
        return "N/A"
    try:
        if date_str.endswith('Z'):
            dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
        else:
            dt = datetime.strptime(date_str, "%Y-%m-%dT%H:%M:%S").replace(tzinfo=timezone.utc)
            
        diff = datetime.now(timezone.utc) - dt
        seconds = int(diff.total_seconds())
        if seconds < 0: seconds = 0
        
        if seconds >= 86400:
            return f"{seconds // 86400}d ago"
        if seconds >= 3600:
            return f"{seconds // 3600}h ago"
        if seconds >= 60:
            return f"{seconds // 60}m ago"
        return "Just now"
    except Exception as e:
        return "Error"

def get_real_backup_status():
    """Lit les statuts r√©els depuis le partage NFS"""
    try:
        with open(BACKUP_JSON_PATH, 'r') as f:
            return json.load(f)
    except:
        return None

# --- OPNsense API ---

def get_opnsense_wan_stats():
    """Get WAN interface statistics from OPNsense API"""
    try:
        url = f"https://{OPNSENSE_IP}/api/diagnostics/interface/getInterfaceStatistics"
        response = requests.get(
            url,
            auth=(OPNSENSE_API_KEY, OPNSENSE_API_SECRET),
            verify=False,
            timeout=2
        )
        if response.status_code == 200:
            data = response.json()
            stats = data.get('statistics', {})
            for interface_name, interface_data in stats.items():
                if interface_data.get('name') == WAN_INTERFACE and 'received-bytes' in interface_data:
                    rx_bytes = int(interface_data.get('received-bytes', 0))
                    tx_bytes = int(interface_data.get('sent-bytes', 0))
                    return (rx_bytes, tx_bytes)
        return (None, None)
    except Exception as e:
        print(f"Error fetching OPNsense stats: {e}")
        return (None, None)

def calculate_wan_bandwidth():
    """Calculate WAN bandwidth usage (download/upload speeds)"""
    global last_wan_stats, last_wan_time
    
    current_stats = get_opnsense_wan_stats()
    current_time = time.time()
    
    if current_stats[0] is None:
        return (None, None)
    
    if last_wan_stats is None or last_wan_time is None:
        last_wan_stats = current_stats
        last_wan_time = current_time
        return (0.0, 0.0)
    
    time_delta = current_time - last_wan_time
    if time_delta < 1:
        return (0.0, 0.0)
    
    rx_delta = current_stats[0] - last_wan_stats[0]
    tx_delta = current_stats[1] - last_wan_stats[1]
    
    download_mbps = (rx_delta / time_delta) / (1024 * 1024)
    upload_mbps = (tx_delta / time_delta) / (1024 * 1024)
    
    last_wan_stats = current_stats
    last_wan_time = current_time
    
    return (download_mbps, upload_mbps)

# --- NETWORK CHECKS ---

def check_ping(ip):
    try:
        subprocess.check_call(
            ['ping', '-c', '1', '-W', '1', ip],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return True
    except:
        return False

def check_port(ip, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1.0)
    try:
        s.connect((ip, int(port)))
        s.close()
        return True
    except:
        return False

def check_service(service):
    name, ip, port = service
    if port:
        return check_port(ip, port)
    else:
        return check_ping(ip)

# --- GRAPHICS HELPERS ---

def rgb888_to_rgb565(r, g, b):
    return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)

def draw_rounded_rect(draw, x, y, width, height, radius, fill, outline=None):
    draw.rectangle((x + radius, y, x + width - radius, y + height), fill=fill)
    draw.rectangle((x, y + radius, x + width, y + height - radius), fill=fill)
    draw.pieslice((x, y, x + radius * 2, y + radius * 2), 180, 270, fill=fill)
    draw.pieslice((x + width - radius * 2, y, x + width, y + radius * 2), 270, 360, fill=fill)
    draw.pieslice((x, y + height - radius * 2, x + radius * 2, y + height), 90, 180, fill=fill)
    draw.pieslice((x + width - radius * 2, y + height - radius * 2, x + width, y + height), 0, 90, fill=fill)
    
    if outline:
        draw.arc((x, y, x + radius * 2, y + radius * 2), 180, 270, fill=outline)
        draw.arc((x + width - radius * 2, y, x + width, y + radius * 2), 270, 360, fill=outline)
        draw.arc((x, y + height - radius * 2, x + radius * 2, y + height), 90, 180, fill=outline)
        draw.arc((x + width - radius * 2, y + height - radius * 2, x + width, y + height), 0, 90, fill=outline)
        draw.line((x + radius, y, x + width - radius, y), fill=outline)
        draw.line((x + radius, y + height, x + width - radius, y + height), fill=outline)
        draw.line((x, y + radius, x, y + height - radius), fill=outline)
        draw.line((x + width, y + radius, x + width, y + height - radius), fill=outline)

# --- PAGE RENDERERS ---

def draw_page_header(draw, title, fonts):
    draw.rectangle((0, 0, SCREEN_WIDTH, 40), fill=(26, 26, 26))
    draw.line((0, 40, SCREEN_WIDTH, 40), fill=COLOR_ACCENT, width=2)
    draw.text((10, 8), title, fill=COLOR_TEXT, font=fonts['lg'])
    
    # Page Indicator
    for i in range(TOTAL_PAGES):
        color = COLOR_ACCENT if i == current_page else COLOR_DIM
        draw.ellipse((440 + (i*12), 16, 448 + (i*12), 24), fill=color)

def draw_page_home(draw, fonts):
    # === GRID LAYOUT ===
    # Row 1: Status Bar (Height 50)
    # Row 2: Main Clock (Height 180)
    # Row 3: Environment (Height 90)

    # --- TOP BAR ---
    draw.rectangle((0, 0, SCREEN_WIDTH, 50), fill=(20, 20, 20))
    draw.line((0, 50, SCREEN_WIDTH, 50), fill=COLOR_BORDER, width=1)
    
    # Left: Uptime
    uptime = get_uptime()
    draw.text((10, 8), "UPTIME", fill=COLOR_DIM, font=fonts['xs'])
    draw.text((10, 22), uptime.split(' ')[0], fill=COLOR_TEXT, font=fonts['md']) # Show only Days
    
    # Right: Pi Temp
    temp = get_temp()
    t_color = COLOR_OK if temp < 60 else COLOR_WARN
    draw.text((SCREEN_WIDTH - 80, 8), "PI TEMP", fill=COLOR_DIM, font=fonts['xs'])
    draw.text((SCREEN_WIDTH - 80, 22), f"{temp:.0f}¬∞C", fill=t_color, font=fonts['md'])

    # Center: System Status Icon
    # Check services
    failed = []
    for svc in SERVICES:
         if not check_service(svc): failed.append(svc[0])
    
    status_color = COLOR_ERR if failed else COLOR_OK
    status_text = "ALERTS" if failed else "ALL OK"
    
    # Draw status badge in center
    cx = SCREEN_WIDTH // 2
    draw_rounded_rect(draw, cx - 50, 5, 100, 40, 5, (0,0,0), status_color)
    w = draw.textlength(status_text, font=fonts['md'])
    draw.text((cx - w/2, 14), status_text, fill=status_color, font=fonts['md'])

    # --- CENTER: CLOCK ---
    timestamp = time.strftime('%H:%M')
    date_str = time.strftime('%A %d %B')
    
    # Very big clock
    w_time = draw.textlength(timestamp, font=fonts['huge'])
    draw.text(((SCREEN_WIDTH - w_time)/2, 80), timestamp, fill=COLOR_TEXT, font=fonts['huge'])
    
    w_date = draw.textlength(date_str, font=fonts['lg'])
    draw.text(((SCREEN_WIDTH - w_date)/2, 160), date_str, fill=COLOR_ACCENT, font=fonts['lg'])

    # --- BOTTOM: WEATHER / ALERTS ---
    y_btm = 230
    h_btm = 90
    draw.line((0, y_btm, SCREEN_WIDTH, y_btm), fill=COLOR_BORDER, width=1)
    
    if failed:
        # Show specific alerts if any
        draw.rectangle((0, y_btm, SCREEN_WIDTH, 320), fill=(40, 0, 0))
        draw.text((20, y_btm + 10), "‚ö†Ô∏è SYSTEM FAILURE", fill=COLOR_ERR, font=fonts['lg'])
        y_list = y_btm + 40
        for f in failed[:2]: # Show max 2 lines
             draw.text((20, y_list), f"‚Ä¢ {f} is DOWN", fill=COLOR_TEXT, font=fonts['md'])
             y_list += 20
    else:
        # Show Weather (Full Width or Centered)
        weather = get_weather()
        if weather:
            w_temp = weather.get('temperature')
            w_code = weather.get('weathercode')
            desc = get_weather_desc(w_code)
            
            # Weather Icon/Text Area
            # Split bottom into Left (Indoor/Pi) and Right (Outdoor) ? 
            # User asked for clean design. Let's center the weather.
            
            # Label
            draw.text((20, y_btm + 10), "BRUSSELS", fill=COLOR_DIM, font=fonts['xs'])
            
            # Big Temp
            draw.text((20, y_btm + 30), f"{w_temp}¬∞C", fill=COLOR_TEXT, font=fonts['xl'])
            
            # Condition
            draw.text((140, y_btm + 35), desc, fill=COLOR_ACCENT, font=fonts['lg'])
            
            # Extra detail (Wind speed?)
            w_wind = weather.get('windspeed')
            draw.text((350, y_btm + 35), f"üí® {w_wind} km/h", fill=COLOR_DIM, font=fonts['sm'])

        else:
             draw.text((150, y_btm + 35), "Weather Unavailable", fill=COLOR_DIM, font=fonts['md'])

def draw_page_network(draw, fonts):
    draw_page_header(draw, "NETWORK STATUS", fonts)
    
    # Services List (Left)
    y_svc = 60
    for svc in SERVICES:
        name, _, _ = svc
        status = check_service(svc)
        ind_color = COLOR_OK if status else COLOR_ERR
        
        draw.ellipse((20, y_svc + 6, 30, y_svc + 16), fill=ind_color)
        draw.text((40, y_svc), name, fill=COLOR_TEXT, font=fonts['md'])
        y_svc += 45

    # WAN Stats (Right)
    card_x = 220
    card_y = 60
    card_width = 240
    
    # Traffic
    draw_rounded_rect(draw, card_x, card_y, card_width, 100, 8, COLOR_CARD_BG, COLOR_BORDER)
    draw.text((card_x + 10, card_y + 10), "WAN TRAFFIC", fill=COLOR_DIM, font=fonts['xs'])
    
    download, upload = calculate_wan_bandwidth()
    
    dl_val = f"{download:.1f}" if download else "0.0"
    ul_val = f"{upload:.1f}" if upload else "0.0"
    
    draw.text((card_x + 10, card_y + 35), f"DL: {dl_val} MB/s", fill=COLOR_ACCENT, font=fonts['lg'])
    draw.text((card_x + 10, card_y + 65), f"UL: {ul_val} MB/s", fill=COLOR_ACCENT, font=fonts['lg'])
    
    # Latency
    lat_y = 180
    draw_rounded_rect(draw, card_x, lat_y, card_width, 80, 8, COLOR_CARD_BG, COLOR_BORDER)
    draw.text((card_x + 10, lat_y + 10), "LATENCY (1.1.1.1)", fill=COLOR_DIM, font=fonts['xs'])
    
    latency = get_internet_latency()
    lat_txt = f"{latency:.0f} ms" if latency else "TIMEOUT"
    lat_color = COLOR_OK if latency and latency < 50 else COLOR_WARN
    
    draw.text((card_x + 10, lat_y + 35), lat_txt, fill=lat_color, font=fonts['xl'])

def draw_page_storage(draw, fonts):
    draw_page_header(draw, "STORAGE & BACKUPS", fonts)
    
    # NAS Usage Bar
    percent, total, used, free = get_disk_usage("/mnt/appdata")
    
    bar_x, bar_y = 20, 60
    bar_w, bar_h = 440, 30
    
    draw.text((bar_x, bar_y - 20), "NAS STORAGE (/mnt/appdata)", fill=COLOR_DIM, font=fonts['xs'])
    
    # Bar background
    draw.rectangle((bar_x, bar_y, bar_x + bar_w, bar_y + bar_h), fill=(30,30,30))
    # Bar fill
    fill_w = int(bar_w * (percent / 100))
    bar_color = COLOR_OK if percent < 80 else (COLOR_WARN if percent < 90 else COLOR_ERR)
    draw.rectangle((bar_x, bar_y, bar_x + fill_w, bar_y + bar_h), fill=bar_color)
    
    draw.text((bar_x + 10, bar_y + 5), f"{used//(1024**3)}GB used of {total//(1024**3)}GB ({percent:.1f}%)", fill=COLOR_TEXT, font=fonts['sm'])

    # Backups List
    y_start = 130
    draw.text((20, y_start - 20), "LATEST BACKUPS", fill=COLOR_DIM, font=fonts['xs'])
    
    real_backups = get_real_backup_status()
    if real_backups:
        y = y_start
        for key, data in real_backups.items():
            is_ok = data.get('status') == 'ok'
            label = data.get('label', key)
            time_str = get_time_ago(data.get('last_run'))
            
            # Draw row background
            draw.rectangle((20, y, 460, y + 40), fill=COLOR_CARD_BG)
            
            # Status dot
            dot_color = COLOR_OK if is_ok else COLOR_ERR
            draw.ellipse((30, y + 15, 40, y + 25), fill=dot_color)
            
            draw.text((50, y + 10), label, fill=COLOR_TEXT, font=fonts['md'])
            draw.text((300, y + 10), time_str, fill=COLOR_DIM, font=fonts['md'])
            
            y += 50
    else:
        draw.text((20, y_start), "No backup data found", fill=COLOR_WARN, font=fonts['md'])

# --- INPUT HANDLING ---

def input_loop():
    """Thread to handle touch input"""
    global current_page, screen_on
    
    if not HAS_EVDEV:
        print("evdev not found, auto-cycling pages")
        while True:
            time.sleep(10)
            current_page = (current_page + 1) % TOTAL_PAGES
            screen_on = True # Always on if cycling
    
    # Find touch device
    devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
    touch_device = None
    for dev in devices:
        if 'touch' in dev.name.lower() or 'ft6x06' in dev.name.lower(): # Common names
            touch_device = dev
            break
            
    if not touch_device:
        # Fallback to first device that supports ABS events if no explicit touch name
        for dev in devices:
             if evdev.ecodes.EV_ABS in dev.capabilities():
                 touch_device = dev
                 break
    
    if not touch_device:
        print("No touch device found. Auto-cycling.")
        while True:
            time.sleep(10)
            current_page = (current_page + 1) % TOTAL_PAGES
            return

    print(f"Using input device: {touch_device.name}")
    
    try:
        for event in touch_device.read_loop():
            if event.type == evdev.ecodes.EV_KEY and (event.code == evdev.ecodes.BTN_TOUCH or event.code == evdev.ecodes.BTN_LEFT):
                if event.value == 1: # Key down
                    if not screen_on:
                        screen_on = True
                    else:
                        current_page = (current_page + 1) % TOTAL_PAGES
    except Exception as e:
        print(f"Input error: {e}")

# --- MAIN ---

def main():
    global screen_on
    
    try:
        font_huge = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 64)
        font_xl = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 32)
        font_lg = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 20)
        font_md = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 16)
        font_sm = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 14)
        font_xs = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", 11)
    except:
        font_huge = ImageFont.load_default()
        font_xl = ImageFont.load_default()
        font_lg = ImageFont.load_default()
        font_md = ImageFont.load_default()
        font_sm = ImageFont.load_default()
        font_xs = ImageFont.load_default()
    
    fonts = {
        'huge': font_huge, 'xl': font_xl, 'lg': font_lg, 
        'md': font_md, 'sm': font_sm, 'xs': font_xs
    }

    # Start input thread
    input_thread = threading.Thread(target=input_loop, daemon=True)
    input_thread.start()
    
    screen_on = True
    
    print("Dashboard started. Touch screen to switch pages.")

    while True:
        # Check time for auto-off (override if touched recently? simplified for now)
        current_hour = datetime.now().hour
        should_be_on = 8 <= current_hour < 24
        
        # If input thread sets screen_on = True (wake up), we respect it.
        # But we also enforce night mode if inactive? 
        # For this version, let's keep it simple: strict time schedule unless overridden by touch (input loop sets screen_on=True)
        # We need a timer to turn it off again? 
        # Let's trust the input_loop handles wake, and we just render if screen_on is True.
        
        if not should_be_on and screen_on:
            # It's night time, turn off unless woke up recently (TODO: Add timeout)
            # For now, just follow schedule
             pass 

        if screen_on:
            image = Image.new("RGB", (SCREEN_WIDTH, SCREEN_HEIGHT), COLOR_BG)
            draw = ImageDraw.Draw(image)
            
            if current_page == 0:
                draw_page_home(draw, fonts)
            elif current_page == 1:
                draw_page_network(draw, fonts)
            elif current_page == 2:
                draw_page_storage(draw, fonts)
                
            # Render to framebuffer
            try:
                pixels = image.getdata()
                buf = bytearray(SCREEN_WIDTH * SCREEN_HEIGHT * 2)
                for i, (r, g, b) in enumerate(pixels):
                    color = rgb888_to_rgb565(r, g, b)
                    struct.pack_into("<H", buf, i * 2, color)
                
                with open(FB_DEVICE, "wb") as f:
                    f.write(buf)
            except Exception as e:
                # print(f"Render error: {e}") # Reduce log spam
                pass
        
        time.sleep(1) # Refresh rate

if __name__ == "__main__":
    main()
