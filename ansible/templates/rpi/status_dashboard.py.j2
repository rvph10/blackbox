#!/usr/bin/env python3
"""
Raspberry Pi Homelab Dashboard (Enhanced)
Displays system status on 480x320 framebuffer display
"""

import os
import time
import subprocess
import struct
import socket
import re
import requests
import json
import shutil
import threading
import math
from datetime import timedelta, datetime, timezone
from PIL import Image, ImageDraw, ImageFont
import urllib3

# Try importing psutil for better system stats
try:
    import psutil
    HAS_PSUTIL = True
except ImportError:
    HAS_PSUTIL = False

# Try importing evdev for input
try:
    import evdev
    from select import select
    HAS_EVDEV = True
except ImportError:
    HAS_EVDEV = False

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- CONFIGURATION ---
FB_DEVICE = "/dev/fb1"
SCREEN_WIDTH = 480
SCREEN_HEIGHT = 320
SCREEN_TIMEOUT = 300  # 5 minutes

# API Config
OPNSENSE_IP = "{{ vault_gateway_ip }}"
OPNSENSE_API_KEY = "{{ vault_opnsense_api_key }}"
OPNSENSE_API_SECRET = "{{ vault_opnsense_api_secret }}"
WAN_INTERFACE = "pppoe2"

# Weather (Brussels)
LATITUDE = "50.8503"
LONGITUDE = "4.3517"

# Services to monitor
SERVICES = [
    ("Router", "{{ vault_gateway_ip }}", None),
    ("Proxmox", "{{ vault_pve_ip }}", None),
    ("AdGuard", "127.0.0.1", 53),
    ("HomeAsst", "127.0.0.1", 8123),
    ("Homepage", "127.0.0.1", 8082),
    ("NAS", "{{ vault_cargo_ip }}", None),
]

BACKUP_JSON_PATH = "/mnt/appdata/rclone/backup_status.json"

# --- THEME ---
class Colors:
    BG = (18, 18, 18)       # #121212 Very Dark Grey
    CARD_BG = (30, 30, 30)  # #1E1E1E Dark Grey
    TEXT_MAIN = (224, 224, 224) # #E0E0E0
    TEXT_SEC = (160, 160, 160)  # #A0A0A0
    ACCENT = (52, 152, 219) # #3498DB Blue
    SUCCESS = (46, 204, 113) # #2ECC71 Green
    WARNING = (241, 196, 15) # #F1C40F Yellow
    ERROR = (231, 76, 60)   # #E74C3C Red
    BORDER = (50, 50, 50)

# --- DATA MANAGER ---
class DataManager:
    def __init__(self):
        self.lock = threading.Lock()
        self.data = {
            'weather': None,
            'wan_stats': {'dl': 0.0, 'ul': 0.0},
            'latency': None,
            'services': {},
            'backups': {},
            'system': {'cpu': 0, 'ram': 0, 'temp': 0}
        }
        self.last_wan_rx = 0
        self.last_wan_tx = 0
        self.last_wan_check = 0
        
        # Start background threads
        threading.Thread(target=self._update_weather, daemon=True).start()
        threading.Thread(target=self._update_network, daemon=True).start()
        threading.Thread(target=self._update_services, daemon=True).start()
        threading.Thread(target=self._update_system, daemon=True).start()

    def _update_weather(self):
        while True:
            try:
                url = f"https://api.open-meteo.com/v1/forecast?latitude={LATITUDE}&longitude={LONGITUDE}&current_weather=true"
                r = requests.get(url, timeout=10)
                if r.status_code == 200:
                    with self.lock:
                        self.data['weather'] = r.json().get('current_weather')
            except:
                pass
            time.sleep(900) # 15 min

    def _update_network(self):
        while True:
            # WAN Stats
            try:
                url = f"https://{OPNSENSE_IP}/api/diagnostics/interface/getInterfaceStatistics"
                r = requests.get(url, auth=(OPNSENSE_API_KEY, OPNSENSE_API_SECRET), verify=False, timeout=5)
                if r.status_code == 200:
                    stats = r.json().get('statistics', {})
                    for iface in stats.values():
                        if iface.get('name') == WAN_INTERFACE:
                            rx = int(iface.get('received-bytes', 0))
                            tx = int(iface.get('sent-bytes', 0))
                            now = time.time()
                            
                            if self.last_wan_check > 0:
                                dt = now - self.last_wan_check
                                # Ensure dt is reasonable to avoid division by near-zero
                                if dt > 0.5:
                                    dl = (rx - self.last_wan_rx) / dt * 8 / (1024*1024)
                                    ul = (tx - self.last_wan_tx) / dt * 8 / (1024*1024)
                                    
                                    # Sanity check: cap at 10000 Mbps (10Gbps) to avoid glitch spikes
                                    if dl < 0 or dl > 10000: dl = 0
                                    if ul < 0 or ul > 10000: ul = 0

                                    with self.lock:
                                        self.data['wan_stats'] = {'dl': dl, 'ul': ul}
                            
                            self.last_wan_rx = rx
                            self.last_wan_tx = tx
                            self.last_wan_check = now
            except Exception as e:
                # print(f"WAN Error: {e}")
                pass

            # Latency
            try:
                cmd = ['ping', '-c', '1', '-W', '1', '1.1.1.1']
                out = subprocess.check_output(cmd, stderr=subprocess.STDOUT).decode()
                match = re.search(r'time=([\d.]+)', out)
                lat = float(match.group(1)) if match else None
                with self.lock:
                    self.data['latency'] = lat
            except:
                with self.lock:
                    self.data['latency'] = None
            
            time.sleep(5)

    def _update_services(self):
        while True:
            results = {}
            for name, ip, port in SERVICES:
                try:
                    if port:
                        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        s.settimeout(1.0)
                        s.connect((ip, int(port)))
                        s.close()
                        results[name] = True
                    else:
                        subprocess.check_call(['ping', '-c', '1', '-W', '1', ip], 
                                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                        results[name] = True
                except:
                    results[name] = False
            
            # Backups
            try:
                if os.path.exists(BACKUP_JSON_PATH):
                    with open(BACKUP_JSON_PATH, 'r') as f:
                        backups = json.load(f)
                else:
                    backups = {}
            except:
                backups = {}

            with self.lock:
                self.data['services'] = results
                self.data['backups'] = backups
            
            time.sleep(30)

    def _update_system(self):
        while True:
            cpu = 0
            ram = 0
            temp = 0
            
            if HAS_PSUTIL:
                cpu = psutil.cpu_percent()
                ram = psutil.virtual_memory().percent
            
            try:
                with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
                    temp = int(f.read().strip()) / 1000.0
            except:
                pass

            with self.lock:
                self.data['system'] = {'cpu': cpu, 'ram': ram, 'temp': temp}
            
            time.sleep(2)

    def get(self, key):
        with self.lock:
            return self.data.get(key)

# --- UI RENDERER ---
class DashboardUI:
    def __init__(self):
        self.dm = DataManager()
        self.width = SCREEN_WIDTH
        self.height = SCREEN_HEIGHT
        self.fonts = self._load_fonts()
        self.page = 0
        self.total_pages = 3
        
    def _load_fonts(self):
        try:
            base = "/usr/share/fonts/truetype/dejavu/DejaVuSans"
            return {
                'huge': ImageFont.truetype(f"{base}-Bold.ttf", 56),
                'xl': ImageFont.truetype(f"{base}-Bold.ttf", 32),
                'lg': ImageFont.truetype(f"{base}-Bold.ttf", 20),
                'md': ImageFont.truetype(f"{base}-Bold.ttf", 16),
                'sm': ImageFont.truetype(f"{base}.ttf", 14),
                'xs': ImageFont.truetype(f"{base}.ttf", 11),
            }
        except:
            d = ImageFont.load_default()
            return {k: d for k in ['huge', 'xl', 'lg', 'md', 'sm', 'xs']}

    def _draw_card(self, draw, x, y, w, h, title=None):
        # Draw rounded card background
        r = 8
        draw.rounded_rectangle((x, y, x+w, y+h), r, fill=Colors.CARD_BG)
        # draw.rounded_rectangle((x, y, x+w, y+h), r, outline=Colors.BORDER, width=1)
        if title:
            draw.text((x+10, y+8), title, fill=Colors.TEXT_SEC, font=self.fonts['xs'])

    def _draw_progress_bar(self, draw, x, y, w, h, percent, color):
        draw.rectangle((x, y, x+w, y+h), fill=(40,40,40))
        fill_w = int(w * (percent / 100))
        draw.rectangle((x, y, x+fill_w, y+h), fill=color)

    def draw_home(self, draw):
        # Time & Date (Top)
        now = datetime.now()
        t_str = now.strftime("%H:%M")
        d_str = now.strftime("%A, %d %B")
        
        # Center Time
        tw = draw.textlength(t_str, font=self.fonts['huge'])
        draw.text(((self.width - tw)/2, 10), t_str, fill=Colors.TEXT_MAIN, font=self.fonts['huge'])
        
        dw = draw.textlength(d_str, font=self.fonts['lg'])
        draw.text(((self.width - dw)/2, 75), d_str, fill=Colors.ACCENT, font=self.fonts['lg'])

        # Left Card: Weather
        wx, wy, ww, wh = 10, 110, 225, 130
        self._draw_card(draw, wx, wy, ww, wh, "BRUSSELS")
        weather = self.dm.get('weather')
        if weather:
            temp = weather.get('temperature')
            code = weather.get('weathercode')
            desc = self._get_weather_desc(code)
            draw.text((wx+15, wy+35), f"{temp}°C", fill=Colors.TEXT_MAIN, font=self.fonts['xl'])
            draw.text((wx+15, wy+80), desc, fill=Colors.TEXT_SEC, font=self.fonts['md'])
            draw.text((wx+15, wy+100), f"Wind: {weather.get('windspeed')} km/h", fill=Colors.TEXT_SEC, font=self.fonts['sm'])
        else:
            draw.text((wx+15, wy+50), "Loading...", fill=Colors.TEXT_SEC, font=self.fonts['sm'])

        # Right Card: System Resources
        sys = self.dm.get('system')
        sx, sy, sw, sh = 245, 110, 225, 130
        self._draw_card(draw, sx, sy, sw, sh, "SYSTEM HEALTH")
        
        # CPU
        draw.text((sx+15, sy+35), "CPU", fill=Colors.TEXT_MAIN, font=self.fonts['sm'])
        self._draw_progress_bar(draw, sx+55, sy+38, 140, 10, sys['cpu'], Colors.ACCENT)
        draw.text((sx+205, sy+35), f"{int(sys['cpu'])}%", fill=Colors.TEXT_SEC, font=self.fonts['xs'])
        
        # RAM
        draw.text((sx+15, sy+65), "RAM", fill=Colors.TEXT_MAIN, font=self.fonts['sm'])
        self._draw_progress_bar(draw, sx+55, sy+68, 140, 10, sys['ram'], Colors.ACCENT)
        draw.text((sx+205, sy+65), f"{int(sys['ram'])}%", fill=Colors.TEXT_SEC, font=self.fonts['xs'])
        
        # Temp
        t_col = Colors.SUCCESS if sys['temp'] < 60 else Colors.WARNING
        draw.text((sx+15, sy+95), f"Temp: {sys['temp']:.1f}°C", fill=t_col, font=self.fonts['md'])

        # Bottom Status
        failed = [k for k,v in self.dm.get('services').items() if not v]
        if failed:
            status_text = f"ALERT: {', '.join(failed[:2])}"
            status_col = Colors.ERROR
        else:
            status_text = "ALL SYSTEMS OPERATIONAL"
            status_col = Colors.SUCCESS
            
        sw = draw.textlength(status_text, font=self.fonts['md'])
        draw.rounded_rectangle(((self.width-sw)/2 - 10, 260, (self.width+sw)/2 + 10, 290), 15, fill=(30,30,30))
        draw.text(((self.width-sw)/2, 265), status_text, fill=status_col, font=self.fonts['md'])

    def draw_network(self, draw):
        self._draw_page_header(draw, "NETWORK STATUS")
        
        # WAN Card
        wx, wy, ww, wh = 10, 50, 460, 100
        self._draw_card(draw, wx, wy, ww, wh, "WAN INTERFACE")
        wan = self.dm.get('wan_stats')
        
        # DL
        draw.text((wx+30, wy+35), "DOWNLOAD", fill=Colors.TEXT_SEC, font=self.fonts['xs'])
        draw.text((wx+30, wy+50), f"{wan['dl']:.1f}", fill=Colors.SUCCESS, font=self.fonts['xl'])
        draw.text((wx+140, wy+62), "MB/s", fill=Colors.TEXT_SEC, font=self.fonts['sm'])
        
        # UL
        draw.text((wx+250, wy+35), "UPLOAD", fill=Colors.TEXT_SEC, font=self.fonts['xs'])
        draw.text((wx+250, wy+50), f"{wan['ul']:.1f}", fill=Colors.ACCENT, font=self.fonts['xl'])
        draw.text((wx+360, wy+62), "MB/s", fill=Colors.TEXT_SEC, font=self.fonts['sm'])
        
        # Services Grid
        gy = 165
        self._draw_card(draw, 10, gy, 460, 140, "SERVICES & LATENCY")
        
        services = self.dm.get('services')
        lat = self.dm.get('latency')
        
        # Latency
        lx = 30
        ly = gy + 35
        lat_txt = f"{lat:.0f} ms" if lat else "N/A"
        lat_col = Colors.SUCCESS if lat and lat < 50 else Colors.WARNING
        draw.text((lx, ly), "LATENCY:", fill=Colors.TEXT_MAIN, font=self.fonts['sm'])
        draw.text((lx+80, ly), lat_txt, fill=lat_col, font=self.fonts['md'])
        
        # Service list
        sx = 30
        sy = ly + 30
        cols = 2
        col_w = 200
        count = 0
        for name, status in services.items():
            r = count // cols
            c = count % cols
            px = sx + (c * col_w)
            py = sy + (r * 25)
            
            dot_col = Colors.SUCCESS if status else Colors.ERROR
            draw.ellipse((px, py+2, px+10, py+12), fill=dot_col)
            draw.text((px+20, py), name, fill=Colors.TEXT_MAIN, font=self.fonts['sm'])
            count += 1

    def draw_storage(self, draw):
        self._draw_page_header(draw, "STORAGE & BACKUPS")
        
        # Storage Card
        percent, total, used, free = self._get_disk_usage("/mnt/appdata")
        self._draw_card(draw, 10, 50, 460, 80, "NAS STORAGE (/mnt/appdata)")
        
        self._draw_progress_bar(draw, 30, 85, 420, 15, percent, Colors.ACCENT)
        info = f"Used: {used//1024**3} GB  /  Total: {total//1024**3} GB  ({percent:.1f}%)"
        draw.text((30, 105), info, fill=Colors.TEXT_SEC, font=self.fonts['sm'])
        
        # Backups
        self._draw_card(draw, 10, 140, 460, 160, "BACKUP STATUS")
        backups = self.dm.get('backups')
        by = 175
        
        if not backups:
            draw.text((30, by), "No backup data available", fill=Colors.WARNING, font=self.fonts['md'])
        else:
            for k, v in list(backups.items())[:4]: # Max 4 items
                lbl = v.get('label', k)
                status = v.get('status') == 'ok'
                ago = self._get_time_ago(v.get('last_run'))
                
                col = Colors.SUCCESS if status else Colors.ERROR
                draw.text((30, by), "•", fill=col, font=self.fonts['lg'])
                draw.text((50, by+2), lbl, fill=Colors.TEXT_MAIN, font=self.fonts['md'])
                draw.text((300, by+2), ago, fill=Colors.TEXT_SEC, font=self.fonts['sm'])
                by += 30

    def _draw_page_header(self, draw, title):
        draw.text((10, 10), title, fill=Colors.TEXT_MAIN, font=self.fonts['lg'])
        draw.line((10, 40, 50, 40), fill=Colors.ACCENT, width=2)

    def _get_disk_usage(self, path):
        try:
            t, u, f = shutil.disk_usage(path)
            return (u/t)*100, t, u, f
        except:
            return 0, 0, 0, 0

    def _get_time_ago(self, date_str):
        if not date_str: return "-"
        try:
            # Handle timestamps with or without timezone info
            if date_str.endswith('Z'):
                 dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
            else:
                 # Assume UTC if no TZ info provided
                 dt = datetime.fromisoformat(date_str).replace(tzinfo=timezone.utc)
                 
            delta = datetime.now(timezone.utc) - dt
            
            # Handle small clock skews or future dates slightly
            total_seconds = int(delta.total_seconds())
            if total_seconds < 0: total_seconds = 0
            
            days = total_seconds // 86400
            if days > 0: return f"{days}d ago"
            
            hours = total_seconds // 3600
            if hours > 0: return f"{hours}h ago"
            
            mins = total_seconds // 60
            return f"{mins}m ago"
        except Exception as e:
            # print(f"Date error: {e}")
            return "?"

    def _get_weather_desc(self, code):
        if code == 0: return "Clear"
        if code in [1,2,3]: return "Cloudy"
        if code in [45,48]: return "Fog"
        if code in [51,53,55]: return "Drizzle"
        if code in [61,63,65]: return "Rain"
        if code in [71,73,75]: return "Snow"
        return "Unknown"

    def render(self):
        image = Image.new("RGB", (self.width, self.height), Colors.BG)
        draw = ImageDraw.Draw(image)
        
        if self.page == 0: self.draw_home(draw)
        elif self.page == 1: self.draw_network(draw)
        elif self.page == 2: self.draw_storage(draw)
        
        # Page Indicators
        for i in range(self.total_pages):
            c = Colors.ACCENT if i == self.page else Colors.CARD_BG
            draw.ellipse((220 + (i*15), 305, 230 + (i*15), 315), fill=c)
            
        return image

# --- MAIN LOOP ---
def set_backlight(on):
    """Turn display backlight/power on or off"""
    # Method 1: Sysfs Backlight (standard)
    bl_found = False
    for path in ["/sys/class/backlight/rpi_backlight", 
                 "/sys/class/backlight/soc:backlight", 
                 "/sys/class/backlight/gpio-backlight"]:
        if os.path.exists(path):
            try:
                # Get max brightness
                val = 0
                if on:
                    max_path = os.path.join(path, "max_brightness")
                    if os.path.exists(max_path):
                        with open(max_path, "r") as f:
                            val = int(f.read().strip())
                    else:
                        val = 255
                
                with open(os.path.join(path, "brightness"), "w") as f:
                    f.write(str(val))
                bl_found = True
            except:
                pass

    # Method 2: Framebuffer Blanking (fallback)
    try:
        fb_blank_path = f"/sys/class/graphics/{os.path.basename(FB_DEVICE)}/blank"
        if os.path.exists(fb_blank_path):
            val = "0" if on else "1"
            with open(fb_blank_path, "w") as f:
                f.write(val)
    except:
        pass

def write_to_fb(img):
    try:
        pixels = img.getdata()
        buf = bytearray(SCREEN_WIDTH * SCREEN_HEIGHT * 2)
        for i, (r, g, b) in enumerate(pixels):
            c = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3)
            struct.pack_into("<H", buf, i * 2, c)
        
        with open(FB_DEVICE, "wb") as f:
            f.write(buf)
    except:
        pass

def main():
    ui = DashboardUI()
    
    # Input Handling
    screen_on = True
    last_interaction = time.time()
    
    def input_handler():
        nonlocal screen_on, last_interaction
        if not HAS_EVDEV:
            while True:
                time.sleep(10)
                if screen_on: ui.page = (ui.page + 1) % ui.total_pages
            return

        devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
        dev = next((d for d in devices if 'touch' in d.name.lower() or 'ft6x06' in d.name.lower()), None)
        if not dev and devices: dev = devices[0] # Fallback
        
        if dev:
            print(f"Input: {dev.name}")
            for event in dev.read_loop():
                if event.type == evdev.ecodes.EV_KEY and event.value == 1:
                    last_interaction = time.time()
                    if not screen_on:
                        screen_on = True
                    else:
                        ui.page = (ui.page + 1) % ui.total_pages

    threading.Thread(target=input_handler, daemon=True).start()

    print("Dashboard Running...")
    
    # Ensure screen is on at start
    set_backlight(True)
    is_screen_active = True
    
    while True:
        now = time.time()
        
        # Screen timeout logic
        if screen_on and (now - last_interaction > SCREEN_TIMEOUT):
            screen_on = False
            
        if screen_on:
            if not is_screen_active:
                set_backlight(True)
                is_screen_active = True
            
            img = ui.render()
            write_to_fb(img)
        
        else:
            if is_screen_active:
                # Turning off
                # 1. Clear screen
                img = Image.new("RGB", (SCREEN_WIDTH, SCREEN_HEIGHT), (0,0,0))
                write_to_fb(img)
                # 2. Power down
                set_backlight(False)
                is_screen_active = False
            
            time.sleep(0.5)
            continue
        
        time.sleep(0.5)

if __name__ == "__main__":
    main()
